TokenContainer tokenize(const std::string& expression) {
    static const std::map<char, Spec> ops{
        {'+', Add},
        {'-', Sub},
        {'/', Div},
        {'*', Mul},
        {'%', Mod},
        {'^', Pow},
        {'(', LeftPars},
        {')', RightPars},
        {'{', LeftPars},
        {'}', RightPars},
        {',', Comma},
    };

    static const std::map<std::string, Spec> funcs{
        {"fact", Factorial},
        //
        {"sqrt", Sqrt},
        //
        {"sin", Sin},
        {"cos", Cos},
        {"tan", Tan},
        {"ctan", Ctan},
        {"asin", Asin},
        {"acos", Acos},
        {"atan", Atan},
        {"actan", Actan},
        //
        {"min", Min},
        {"max", Max},
        {"log", Log},
        //
        {"lim", Limit},
        {"dt", Derivative},
        {"Int", Integral},
    };

    enum State {
        OperatorState,
        UnaryOperatorState,
        NumberState,
        VariableState,
        FunctionState,
        ReadingState,
    } state = ReadingState;

    TokenContainer tokens;

    for (const auto& ch : expression) {
        switch (state) {
            case ReadingState:  // beggining state
                if (std::isdigit(ch) or ch == '.') {
                    tokens.push_back({Number, std::string(1, ch)});
                    state = NumberState;
                } else if (std::isalpha(ch)) {
                    tokens.push_back({Variable, std::string(1, ch)});
                    state = VariableState;
                } else if (auto it = ops.find(ch); it != ops.end()) {
                    tokens.push_back({it->second, std::string(1, ch)});
                    state = OperatorState;
                }
                break;

            case NumberState:  // digit or '.' found
                if (std::isdigit(ch) or ch == '.') {
                    tokens.back().value.push_back(ch);
                } else if (std::isalpha(ch)) {
                    tokens.push_back({Mul, "*"});
                    tokens.push_back({Variable, std::string(1, ch)});
                    state = VariableState;
                } else if (auto it = ops.find(ch); it != ops.end()) {
                    if (it->second == LeftPars) tokens.push_back({Mul, "*"});
                    tokens.push_back({it->second, std::string(1, ch)});
                    state = OperatorState;
                } else if (std::isblank(ch)) {
                    state = ReadingState;
                }
                break;

            case VariableState:  // alphabetical char or digit after char found
                if (std::isdigit(ch)) {
                    tokens.back().value.push_back(ch);
                } else if (std::isalpha(ch)) {
                    tokens.back().value.push_back(ch);
                    if (auto it = funcs.find(tokens.back().value); it != funcs.end()) {
                        tokens.back().spec = it->second;
                        state = FunctionState;
                    }
                } else if (auto it = ops.find(ch); it != ops.end()) {
                    tokens.push_back({it->second, std::string(1, ch)});
                    state = OperatorState;
                } else if (std::isblank(ch)) {
                    state = ReadingState;
                }
                break;

            case OperatorState:  // one of possible operators found in ops map
                if (std::isdigit(ch) or ch == '.') {
                    tokens.push_back({Number, std::string(1, ch)});
                    state = NumberState;
                } else if (std::isalpha(ch)) {
                    tokens.push_back({Variable, std::string(1, ch)});
                    state = VariableState;
                } else if (auto it = ops.find(ch); it != ops.end()) {
                    if (it->second == LeftPars and tokens.back().spec == RightPars) {
                        tokens.push_back({Mul, "*"});
                    } else if (it->second == Mul and tokens.back().spec == Mul) {
                        tokens.back().spec = Pow;
                        tokens.back().value.push_back('*');
                        break;
                    } else if (it->second == Sub) {
                        tokens.push_back({Number, "-1"});
                        tokens.push_back({Mul, "*"});
                        state = UnaryOperatorState;
                        break;
                    } else if (it->second == Add) {
                        state = UnaryOperatorState;
                        break;
                    }
                    tokens.push_back({it->second, std::string(1, ch)});
                }
                break;

            case UnaryOperatorState:
                if (std::isdigit(ch) or ch == '.') {
                    tokens.push_back({Number, std::string(1, ch)});
                    state = NumberState;
                } else if (std::isalpha(ch)) {
                    tokens.push_back({Variable, std::string(1, ch)});
                    state = VariableState;
                } else if (auto it = ops.find(ch); it != ops.end()) {
                    if (it->second == LeftPars) state = OperatorState;
                    tokens.push_back({it->second, std::string(1, ch)});
                }
                break;

            case FunctionState:  // specific sequence of chars representing math function found
                if (std::isdigit(ch) or std::isalpha(ch)) {
                    tokens.back().value.push_back(ch);
                    tokens.back().spec = Variable;
                    state = VariableState;
                } else if (auto it = ops.find(ch); it != ops.end()) {
                    tokens.push_back({it->second, std::string(1, ch)});
                    state = OperatorState;
                }
                break;
        }
    }
    std::cout << std::endl;
    for (const auto& el : tokens)
        std::cout << "'" << el.value << "', ";
    std::cout << std::endl;
    return tokens;
}